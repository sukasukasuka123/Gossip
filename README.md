# Gossip 协议系统说明文档

一个实现 Gossip 协议的分布式消息传播系统，具有自适应 TTL 管理和高效的状态追踪功能。

## 系统概述

本系统实现了一个点对点的 Gossip 协议，节点通过向邻居子集广播消息（基于 fanout 的传播）进行通信。系统具有自动去重检测、基于确认的消息确认机制，以及自适应的消息状态管理。

## 核心组件

### 1. 消息管理 (`MessageManage`)

**GossipMessage[T]**: 泛型消息结构，包含：
- `Hash`: 消息唯一标识符
- `FromHash`: 发送节点标识符
- `Payload`: 泛型载荷，类型为 T

**GossipAck**: 确认消息结构，用于确认消息接收

### 2. 节点管理 (`NodeManage`)

**GossipNode[T]**: 核心节点实现，具有：
- 邻居管理和端点追踪
- 基于代价的路由决策
- 可配置的 fanout（默认：3）
- 可插拔的存储、传输、路由和日志接口

**核心方法**:
- `HandleReceiveMessage`: 处理接收的消息，初始化状态，发送 ACK，并向邻居广播
- `HandleReceiveAck`: 处理确认消息，当所有邻居确认后触发状态清理
- `AddNeighbor`: 动态添加邻居并更新 TTL 限制

### 3. 存储 (`Storage`)

**LocalStorage**: 使用 `sync.Map` 和原子操作实现的线程安全消息状态管理

**功能特性**:
- 通过 `seenCache` 实现重复检测
- 针对每条消息的邻居状态追踪
- 自适应 TTL 系统，具有双层超时机制：
  - **短 TTL (Short TTL)**: 活跃消息状态的动态超时（2-64 秒）
  - **长 TTL (Long TTL)**: 扩展缓存保留时间（默认：10 分钟）
- TTL 过期后自动清理状态

**自适应 TTL 机制**:
- **添加邻居时**: 短 TTL 限制翻倍（指数增长，最大 64 秒）
- **收到 ACK 时**: 当前 TTL 向限制值靠近（指数逼近）
- **周期性衰减**: 每 3 秒当前 TTL 减少 1 秒（渐进式降低，最小 2 秒）

### 4. 路由 (`Router`)

**FanoutRouter**: 默认路由策略，功能包括：
- 从未接收/未确认消息的邻居中选择目标
- 按代价优先排序（升序）
- 遵守配置的 fanout 限制

### 5. 传输 (`TransportMessage`)

**HttpTransport**: 基于 HTTP 的消息传输，实现：
- `SendMessage`: POST 到 `/RecieveMessage` 端点
- `SendAck`: POST 到 `/RecieveAck` 端点

### 6. 日志 (`Logger`)

**LogStruct**: 基于文件的日志记录器，具有：
- 带时间戳的日志条目
- 并发安全的文件操作
- 双输出（文件 + 控制台）

## 系统流程

### 消息传播过程

1. **初始广播**: 源节点将消息发送给自己
2. **状态初始化**: 节点为所有邻居初始化状态映射（全部标记为 `false`）
3. **立即 ACK**: 接收节点立即向发送者返回 ACK
4. **重复检查**: 如果消息已见过，只发送 ACK（不再广播）
5. **Fanout 选择**: 路由器选择前 N 个（按代价）未联系的邻居
6. **标记并发送**: 在异步发送前将选定的邻居标记为已联系
7. **接收 ACK**: 收到 ACK 后，邻居状态更新为 `true`
8. **完成检查**: 当所有邻居标记为 `true` 时，安排延迟删除状态
9. **延迟清理**: 在 `邻居数量 * 1 秒` 延迟后删除状态

### TTL 动态调整示例

```
初始状态: shortTTL=4秒, shortLimit=8秒

事件: 添加新邻居
→ shortLimit: 8秒 → 16秒

事件: 收到 ACK (shortTTL=4秒, shortLimit=16秒)
→ 增量 = (16-4)/2 = 6秒
→ shortTTL: 4秒 → 10秒

事件: 3秒周期触发（无活动）
→ shortTTL: 10秒 → 9秒 → 8秒 → 7秒...

事件: 收到 ACK (shortTTL=7秒, shortLimit=16秒)
→ 增量 = (16-7)/2 = 4.5秒 → 5秒（向上取整）
→ shortTTL: 7秒 → 12秒
```

## 测试配置 (main.go)

测试设置创建了一个 10 节点全连接网络：

- **节点**: `node1.txt` 到 `node10.txt`
- **端口**: 8081-8090
- **拓扑**: 全网格（每个节点连接到所有其他节点）
- **测试消息**: 从节点 1-4 发送 4 条消息
- **消息格式**: `test-message-{1-4}`

### 运行测试

```bash
go run main.go
```

**预期行为**:
- 所有 10 个节点接收全部 4 条消息
- 每条消息每跳使用 fanout=3 传播
- 日志写入 `node1.txt` 到 `node10.txt`
- 测试在 10 秒后完成

## 配置参数

| 参数 | 默认值 | 描述 |
|-----------|---------|-------------|
| Fanout | 3 | 每条消息最多广播给多少个邻居 |
| Short TTL | 4秒 | 初始活跃状态超时 |
| Short Limit | 8秒 | 初始最大 TTL（随邻居增长） |
| Long TTL | 10分钟 | 已见缓存保留期 |
| TTL 衰减间隔 | 3秒 | TTL 减少的频率 |
| 清理间隔 | 1分钟 | 已见缓存清理频率 |

## API 端点

### POST `/RecieveMessage`
接收 `GossipMessage[T]` JSON 请求体
- 为新消息初始化状态
- 向发送者发送 ACK
- 向 fanout 邻居广播

### POST `/RecieveAck`
接收 `GossipAck` JSON 请求体
- 更新邻居状态
- 所有邻居确认后触发清理

## 关键设计特性

1. **原子状态管理**: 使用无锁 CAS 操作进行状态更新
2. **重复抑制**: 已见缓存防止冗余处理
3. **自适应 TTL**: 根据网络活动自动调整超时
4. **延迟删除**: 宽限期防止过早清理状态
5. **泛型实现**: 通过 Go 泛型支持类型安全的载荷
6. **可插拔架构**: 存储、传输、路由和日志的接口化设计

## 依赖项

```go
github.com/gin-gonic/gin  // HTTP 路由框架
```

## 文件结构

```
Gossip/
├── MessageManage/      # 消息和 ACK 结构
├── NodeManage/         # 核心 gossip 节点逻辑
│   ├── Logger/         # 日志接口和实现
│   ├── Router/         # 路由策略
│   ├── Storage/        # 状态管理和 TTL 系统
│   └── TransportMessage/ # 网络传输
└── main.go             # 测试设置和执行
```

## 当前限制

- 无加密或身份验证
- 基于 HTTP 的传输（非生产级别）
- 仅内存状态（无持久化）
- 固定的 fanout 配置
- 无故障检测或恢复机制

## 未来改进方向

- 添加 TLS 支持以实现安全通信
- 实现故障检测和节点健康检查
- 支持动态 fanout 调整
- 添加指标和监控端点
- 实现状态持久化以实现崩溃恢复
- 支持自定义载荷序列化格式

## 工作原理总结

这是一个去中心化的消息传播系统。每个节点维护一张消息状态表，记录每条消息在各个邻居处的传播状态。当节点收到新消息时：

1. 首先检查是否已见过（去重）
2. 立即向发送者返回 ACK（确认收到）
3. 根据 fanout 策略选择若干邻居进行转发
4. 收集所有邻居的 ACK
5. 当所有邻居都确认后，延迟删除该消息的状态

系统通过自适应 TTL 机制平衡内存使用和可靠性：网络活跃时延长状态保留时间，网络空闲时缩短保留时间。这确保了消息能够可靠传播到所有节点，同时避免了状态表无限增长。
